"""CoreLink - Main Flask application."""

import argparse
import os
import socket
import time
from datetime import timedelta

from flask import Flask, render_template, redirect, url_for, request, send_file, abort
from flask_socketio import SocketIO, emit
from flask_login import (
    LoginManager, login_user, logout_user, login_required, current_user,
)

from auth import authenticate_pam, User, check_rate_limit, record_failure
from gossip import GossipNode
from gpu import get_local_gpu_info
from monitor import AppMonitor

VERSION = "0.04.0"

# ---------------------------------------------------------------------------
# Flask application setup
# ---------------------------------------------------------------------------

app = Flask(__name__)

# Read persistent secret key (generated by entrypoint.sh)
_secret_path = "/data/secret_key"
if os.path.isfile(_secret_path):
    with open(_secret_path) as fh:
        app.config["SECRET_KEY"] = fh.read().strip()
else:
    app.config["SECRET_KEY"] = os.urandom(32).hex()

# Security-hardened cookie settings
app.config["REMEMBER_COOKIE_DURATION"] = timedelta(days=30)
app.config["REMEMBER_COOKIE_SECURE"] = True
app.config["REMEMBER_COOKIE_HTTPONLY"] = True
app.config["REMEMBER_COOKIE_SAMESITE"] = "Lax"
app.config["SESSION_COOKIE_SECURE"] = True
app.config["SESSION_COOKIE_HTTPONLY"] = True
app.config["SESSION_COOKIE_SAMESITE"] = "Lax"
app.config["PERMANENT_SESSION_LIFETIME"] = timedelta(hours=8)

# Flask-SocketIO (eventlet async mode for native WebSocket support)
socketio = SocketIO(app, async_mode="eventlet")

# Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = "login"


@login_manager.user_loader
def load_user(user_id):
    """Reload user from session.  Verify the user still exists in /etc/passwd."""
    import pwd
    try:
        pwd.getpwnam(user_id)
        return User(user_id)
    except KeyError:
        return None


# ---------------------------------------------------------------------------
# Initialize GPU discovery and gossip protocol
# ---------------------------------------------------------------------------

_hostname = os.environ.get("CORELINK_HOSTNAME", socket.gethostname())
_gpu_info = get_local_gpu_info()
_gossip_port = int(os.environ.get("CORELINK_GOSSIP_PORT", "47100"))

monitor = AppMonitor()
_metrics = monitor.get_metrics()

gossip = GossipNode(
    hostname=_hostname,
    local_gpu_info=_gpu_info,
    port=_gossip_port,
    link_speed=_metrics.get("link_speed", 0),
    link_speed_max=_metrics.get("link_speed_max", 0),
    ntp_drift=_metrics.get("ntp_drift"),
)


# ---------------------------------------------------------------------------
# Routes
# ---------------------------------------------------------------------------

@app.route("/")
@login_required
def index():
    return render_template(
        "console.html",
        version=VERSION,
        username=current_user.username,
        hostname=_hostname,
    )


@app.route("/login", methods=["GET", "POST"])
def login():
    if current_user.is_authenticated:
        return redirect(url_for("index"))

    error = None
    if request.method == "POST":
        username = request.form.get("username", "").strip()
        password = request.form.get("password", "")
        remember = request.form.get("remember") == "on"
        client_ip = request.remote_addr or "unknown"

        if not username or not password:
            error = "Username and password are required."
        elif not check_rate_limit(client_ip):
            error = "Too many failed attempts. Please wait 30 seconds."
        elif authenticate_pam(username, password):
            user = User(username)
            login_user(user, remember=remember)
            next_page = request.args.get("next")
            return redirect(next_page or url_for("index"))
        else:
            record_failure(client_ip)
            error = "Invalid username or password."

    return render_template("login.html", version=VERSION, error=error)


@app.route("/logout")
@login_required
def logout():
    logout_user()
    return redirect(url_for("login"))


@app.route("/ca.pem")
def download_ca():
    """Serve the CA certificate for browser installation (unauthenticated)."""
    ca_path = "/data/ssl/ca.pem"
    if not os.path.isfile(ca_path):
        abort(404)
    return send_file(
        ca_path,
        mimetype="application/x-pem-file",
        as_attachment=True,
        download_name="corelink-ca.pem",
    )


# ---------------------------------------------------------------------------
# SocketIO events
# ---------------------------------------------------------------------------

@socketio.on("connect")
def handle_connect():
    """Reject unauthenticated WebSocket connections."""
    if not current_user.is_authenticated:
        return False
    # Send initial cluster state to the connecting client
    emit("cluster_state", {
        "nodes": gossip.get_cluster_state(),
        "monitor": monitor.get_metrics(),
    })


@socketio.on("request_update")
def handle_request_update():
    """Manual refresh requested by the client."""
    if not current_user.is_authenticated:
        return
    emit("cluster_state", {
        "nodes": gossip.get_cluster_state(),
        "monitor": monitor.get_metrics(),
    })


# ---------------------------------------------------------------------------
# Background task â€” push gossip state to all connected clients
# ---------------------------------------------------------------------------

def _push_cluster_state():
    """Emit cluster_state to every connected client every 3 seconds."""
    while True:
        socketio.sleep(3)
        monitor.collect()
        metrics = monitor.get_metrics()
        gossip.set_net_kbps(metrics["net_mbps"] * 1000)
        gossip.set_ntp_drift(metrics.get("ntp_drift"))
        socketio.emit("cluster_state", {
            "nodes": gossip.get_cluster_state(),
            "monitor": metrics,
        })


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--port", type=int, default=443)
    args = parser.parse_args()

    ssl_cert = "/data/ssl/cert.pem"
    ssl_key = "/data/ssl/key.pem"

    print("CoreLink v%s" % VERSION)
    print("  Hostname : %s" % _hostname)
    print("  GPUs     : %d" % len(_gpu_info))
    for gpu in _gpu_info:
        print("    GPU%s: %s" % (gpu["id"], gpu["model"]))
    print("  Port     : %d (HTTPS)" % args.port)
    print("  Gossip   : %d/udp" % _gossip_port)
    ca_cert = "/data/ssl/ca.pem"
    if os.path.isfile(ca_cert):
        print("  TLS      : CA-signed (download CA at https://%s:%d/ca.pem)"
              % (_hostname, args.port))
    else:
        print("  TLS      : Self-signed")
    print("")

    # Start gossip protocol
    gossip.start()

    # Start background SocketIO pusher
    socketio.start_background_task(_push_cluster_state)

    # Run HTTPS server
    socketio.run(
        app,
        host="0.0.0.0",
        port=args.port,
        certfile=ssl_cert,
        keyfile=ssl_key,
        log_output=True,
    )
